---
title: API-Clients erstellen
sidebar_label: API-Clients erstellen
---

# Einf√ºhrung {#intro}

Bei der Arbeit mit der mittwald-API gibt es viele Gr√ºnde, warum du
einen eigenen API-Client erstellen m√∂chtest ‚Äì oder sogar musst ‚Äì,
anstatt ausschlie√ülich auf offizielle SDKs zu setzen. W√§hrend
Sprachpr√§ferenzen und die Einhaltung von Unternehmensstandards h√§ufige
Beweggr√ºnde sind, gibt es mehrere zus√§tzliche Faktoren, die du
ber√ºcksichtigen solltest:

- **Programmiersprache und Technology Stack**  
  Nicht alle Sprachen oder Plattformen verf√ºgen √ºber ein offizielles SDK.
  Wenn dein Projekt eine Sprache, ein Framework oder eine Umgebung verwendet,
  die nicht von Haus aus unterst√ºtzt wird, sorgt ein eigener Client f√ºr eine
  reibungslose Integration.

- **Erweiterte oder nicht standardm√§√üige Authentifizierungsabl√§ufe**  
  Einige Projekte erfordern flexible Authentifizierungsmethoden: die Verwendung
  von Tokens aus Umgebungsvariablen, die Sicherung von Extension-Interaktionen,
  die Handhabung von Session-Tokens in Browser-Szenarien oder die automatische
  Rotation von Secrets. Offizielle Clients decken m√∂glicherweise nicht alle neuen
  oder komplexen organisationsspezifischen Authentifizierungsanforderungen ab.

- **Integration in spezialisierte Umgebungen**  
  Von CLI-Tools √ºber browserbasierte Apps, Serverless-Funktionen bis hin zu
  eingebetteten Systemen ‚Äì Plattform- und Laufzeitbeschr√§nkungen erfordern manchmal
  ma√ügeschneiderte Clients, die f√ºr ihre spezifische Umgebung optimiert sind.

- **Anpassungsf√§higkeit an API-√Ñnderungen und experimentelle Features**  
  APIs entwickeln sich weiter ‚Äì manchmal schnell. Das Erstellen eines eigenen Clients
  kann dir helfen, Beta-Features zu nutzen, mit Endpunkten zu arbeiten, die noch nicht
  offiziell unterst√ºtzt werden, oder dich schnell an Breaking Changes oder
  herstellerspezifische Erweiterungen anzupassen.

- **Architektonische und Integrationsflexibilit√§t**  
  Teams mit fortgeschrittenen Architekturmustern (wie Microservices, Middleware-Layering
  oder Plugin-Systemen) ben√∂tigen oft mehr Kontrolle, wie z. B. das Einf√ºgen von
  benutzerdefiniertem Logging, Tracing oder Rate-Limiting auf Client-Ebene oder die
  Zusammensetzung h√∂herwertiger Abstraktionen √ºber dem API-Transport.

- **Sicherheit, Compliance und Auditing**  
  Bestimmte Branchen und Organisationen verlangen, dass Code vollst√§ndig auditierbar
  oder selbst gehostet ist, sich eng in interne Sicherheitstools integriert oder
  Credentials auf benutzerdefinierte Weise verwaltet. Das Erstellen eines eigenen
  Clients erm√∂glicht es dir, diese Anforderungen zu erf√ºllen.

- **Testing, Mocking und lokale Entwicklung**  
  Eigene Clients k√∂nnen Features enthalten, die f√ºr lokale Entwicklung und CI n√ºtzlich
  sind, wie Mock-Datenmodi, Test-Doubles oder vereinfachte Authentifizierung f√ºr
  fr√ºhes Prototyping, ohne sensible Credentials preiszugeben.

- **Dokumentation, Lokalisierung und Onboarding**  
  Manchmal ist ein eigener Client ein strategisches Asset: Er kann in der Muttersprache
  des Teams geschrieben und dokumentiert werden oder mit Onboarding-Beispielen und
  Anleitungen f√ºr die Entwickler deiner Organisation ma√ügeschneidert werden.

- **Dependency Management und Code Ownership**  
  Ein eigener Client erm√∂glicht es dir, Dependencies zu pinnen, die API-Oberfl√§che an
  deine Bed√ºrfnisse anzupassen und externe Drift zu vermeiden ‚Äì entscheidend f√ºr
  Organisationen mit strengen Stabilit√§ts- oder Sicherheitsstandards.

**Zusammenfassend:**  
Eigene API-Clients sind nicht nur eine Frage pers√∂nlicher oder Unternehmenspr√§ferenzen ‚Äì
sie sind ein wichtiger Enabler f√ºr Integration, Compliance, Sicherheit und
Entwicklerproduktivit√§t.

Indem du einen auf deine spezifischen Anforderungen zugeschnittenen Client entwickelst,
stellst du sicher, dass deine Anwendungen robust, wartbar und zukunftssicher bleiben.

# Vorbereitung {#preparation}

Eine gr√ºndliche Vorbereitung ist die Grundlage f√ºr einen reibungslosen und effizienten
Entwicklungsprozess f√ºr eigene API-Clients.

Mit der richtigen Vorarbeit ist es oft m√∂glich, den Gro√üteil deines Clients automatisch
zu generieren, mit minimaler manueller Intervention. Im Folgenden sind wichtige
Vorbereitungsbereiche aufgef√ºhrt, die du vor dem Start ber√ºcksichtigen solltest:

## Verstehe deinen Use Case und die Zielumgebung

- **Wo wird der Client ausgef√ºhrt?**  
  Identifiziere, ob dein Client in serverseitigen Apps, browserbasierten Skripten,
  Kommandozeilen-Tools, Serverless-Funktionen oder CI/CD-Pipelines verwendet wird.
- **Wer sind die Endnutzer?**  
  Ber√ºcksichtige interne Teams, externe Kunden oder Automatisierungstools, da dies
  Features und Benutzerfreundlichkeit beeinflusst.
- **Gibt es Plattformbeschr√§nkungen?**  
  Einige Umgebungen (wie Browser oder Serverless) k√∂nnen Einschr√§nkungen bei
  Authentifizierungsmethoden, Storage oder Dependencies haben.

## Sammle und √ºberpr√ºfe die OpenAPI-Spezifikation

Lade die aktuelle OpenAPI-Spezifikation f√ºr die API herunter:

```shellsession
(user@local) $ curl --location --fail --silent 'https://api.mittwald.de/v2/openapi.json' > openapi.json
```

- **Validiere die Spezifikation:**  
  Verwende OpenAPI-Validatoren (z. B. [Swagger Editor](https://editor.swagger.io/)),
  um auf Fehler oder Inkonsistenzen zu pr√ºfen.
- **Pr√ºfe auf Vollst√§ndigkeit:**  
  Stelle sicher, dass alle erforderlichen Endpunkte, Authentifizierungsabl√§ufe und
  Schemas dokumentiert sind.

## Kl√§re Authentifizierungs- und Sicherheitsanforderungen

- **Authentifizierungsmethoden:**  
  Muss dein Client API-Tokens, OAuth2, Extension-Secrets oder zus√§tzliche Mechanismen
  unterst√ºtzen?
- **Secret Management:**  
  Stelle sicher, dass erforderliche Tokens oder Secrets verf√ºgbar sind und sicher
  eingebunden werden k√∂nnen (z. B. √ºber Umgebungsvariablen, Config-Dateien, sichere Vaults).
- **Plane f√ºr sichere Speicherung:**  
  Hardcode niemals sensible Informationen im Client.

## W√§hle und richte deine Code-Generierungstools ein

- **W√§hle einen Code-Generator:**  
  Tools wie [OpenAPI Generator](https://openapi-generator.tech/),
  [Swagger Codegen](https://github.com/swagger-api/swagger-codegen) oder
  [Autorest](https://aka.ms/autorest) k√∂nnen Clients in vielen Sprachen erstellen.
- **Pr√ºfe die Kompatibilit√§t:**  
  Stelle sicher, dass dein gew√§hltes Tool deine bevorzugte Sprache und die
  bereitgestellte OpenAPI-Version unterst√ºtzt.
- **Installiere den Generator:**  
  Richte das Codegen-Toolkit ein und mache dich mit seinen Optionen und
  Konfigurationsdateien vertraut.

## Bereite Generator- und Projektkonfiguration vor

- **Passe Generator-Einstellungen an:**  
  Konfiguriere Type-Mappings, Serialisierungsoptionen, HTTP-Client-Auswahl,
  Package-Naming und Code-Style entsprechend den Konventionen deines Projekts.
- **Unterst√ºtzende Dateien:**  
  Bereite Konfigurationen/Templates f√ºr Umgebungsvariablen, CI-Skripte,
  Dokumentation und Testing vor.
- **Versionierungs-Setup:**  
  Entscheide, wie dein Client die API-Version widerspiegeln soll ‚Äì dies hilft
  Konsumenten, die API-Kompatibilit√§t zu verstehen.

## Plane f√ºr API-Evolution und Wartung

- **Automatisiere Updates:**  
  Erw√§ge, den gesamten Fetch-Generate-Test-Prozess zu skripten, damit dein Client
  mit der API-Evolution Schritt h√§lt.
- **√úberwache API-√Ñnderungen:**  
  Abonniere API-Changelogs und sei bereit, bei √Ñnderungen der OpenAPI-Spezifikation
  neu zu generieren und zu testen.
- **Handhabung von Breaking Changes:**  
  Richte eine Versionskontrolle ein und plane, wie du Client-Updates verwaltest,
  wenn die API-Struktur aktualisiert wird.

## Identifiziere spezielle API-Features und Custom Logic

- **Spezielle Endpunkte:**  
  Beachte, ob die API Pagination, File-Uploads, Webhooks, lang laufende Operationen
  oder andere fortgeschrittene Patterns enth√§lt. Code-Generatoren erfordern
  m√∂glicherweise zus√§tzliche Konfiguration oder manuelle Anpassungen daf√ºr.
- **Fehlerbehandlung:**  
  Pr√ºfe auf konsistente Fehlerantwortformate und plane, wie der generierte Client
  diese anzeigen soll.
- **Eigene Workflows:**  
  Wenn bestimmte Business-Flows zusammengesetzte oder mehrstufige API-Interaktionen
  erfordern, dokumentiere diese Szenarien, um den Client nach der Generierung zu erweitern.

Durch gr√ºndliche Vorbereitung entlang dieser Linien beschleunigst du nicht nur den
initialen Client-Build, sondern stellst auch sicher, dass deine L√∂sung robust, sicher
und wartbar bleibt, w√§hrend sich sowohl deine Codebasis als auch die mittwald-API
weiterentwickeln.

# Philosophie {#philosophy}

Ein reibungsloser Entwicklungsworkflow basiert auf der Arbeit mit zuverl√§ssigen,
standardkonformen Tools und Spezifikationen. Beim Erstellen eigener API-Clients aus
OpenAPI-Spezifikationen solltest du vor allem auf Einfachheit und Wartbarkeit achten.

**Lass den Generator die Arbeit machen:**  
Moderne OpenAPI-Client-Generatoren sind leistungsstark und bew√§ltigen die meisten
typischen API-Komplexit√§ten automatisch. In den meisten F√§llen sollte minimale
Konfiguration oder manuelle Intervention notwendig sein, vorausgesetzt, die
API-Spezifikation ist gut gepflegt.

Wenn du auf Einschr√§nkungen oder Eigenheiten st√∂√üt ‚Äì wie subtile Warnungen,
Versionsunterschiede oder Abweichungen vom OpenAPI-Standard ‚Äì priorisiere die
Behebung der Grundursache, idealerweise durch Verbesserung oder Korrektur der
Spezifikation selbst. Das Melden von Problemen oder das Einbringen von Fixes
zur API-Spezifikation hilft der Community und verbessert die Ergebnisse f√ºr alle.

**Vermeide unn√∂tige Komplexit√§t:**  
Versuche, darauf zu verzichten, Workarounds oder eigene Patches f√ºr jeden Edge Case
in generierten Clients einzuf√ºhren. Die Konzentration auf Generator-Konfiguration,
anstatt auf manuelle Code-√Ñnderungen oder Ad-hoc-"Fixes" an der Spezifikation,
h√§lt deinen Workflow nachhaltig und zukunftssicher.

> üå± **Pflege deinen Generierungsprozess, nicht das Output.**  
> Investiere deine manuellen Bem√ºhungen in die Verbesserung von Automatisierung, Testing und Pipeline-Robustheit ‚Äì statt in aufw√§ndige Bearbeitungen von generiertem Code.

Zu den beliebten OpenAPI-Generatoren geh√∂ren [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) und andere. Teste generierte Clients mit einfachen API-Requests, um schnell zu validieren, dass sie wie erwartet funktionieren.

**Fazit:**  
Ein wenig Disziplin bei der Pflege eines sauberen, automatisierten Generierungs-Workflows
reduziert nicht nur technische Schulden, sondern spart dir und deinem Team Zeit bei
jedem neuen API-Release.

# Beispiel ‚Äì Python API Client {#example-python}

**Anforderungen:**
- Python-Installation (Version 3.10+ empfohlen)
- Grundkenntnisse in Bash, Python, `pip` und virtuellen Umgebungen

Ein Python-API-Client kann mit dem [openapi-python-client-Modul](https://github.com/openapi-generators/openapi-python-client) generiert werden.

Da der Client selbst zu 100% generiert wird, konzentrieren wir uns auf die Erstellung
einer **Pipeline** f√ºr automatisierte Client-Erstellung, Release und Updates. Im
Folgenden beginnen wir mit dem manuellen Prozess zur Veranschaulichung ‚Äì Automatisierung
und Wartung werden im n√§chsten Abschnitt behandelt.

## Einen Python mittwald API Client erstellen

Bevor du den Workflow automatisierst, beginne damit, manuell einen Client in deiner
Konsole zu generieren. Erstelle zun√§chst deinen Projektordner, richte eine virtuelle
Python-Umgebung ein und installiere den Client-Generator:

```shellsession
(user@local) $ mkdir python-api-client
(user@local) $ cd python-api-client
(user@local) $ python3 -m venv venv
(user@local) $ source venv/bin/activate
(venv)(user@local) $ pip install openapi-python-client
```

:::note
`(venv)` zeigt an, dass deine virtuelle Umgebung aktiv ist. Dies √§ndert deinen `PATH`,
sodass `python` auf den lokalen Interpreter zeigt. Die Aktivierung f√ºr bash/zsh wird
gezeigt; f√ºr andere Shells (PowerShell, fish, etc.) siehe `venv/bin/`. Deaktivierung
mit `deactivate`. Unter Windows ist die Aktivierung `venv\Scripts\activate`.
:::

### Die OpenAPI-Spezifikation herunterladen

```shellsession
(venv)(user@local) $ curl --location --fail --silent 'https://api.mittwald.de/v2/openapi.json' > openapi.json
```

### Den Code-Generator ausf√ºhren

```shellsession
(venv)(user@local) $ openapi-python-client generate --path ./openapi.json
```

Der Generator kann Warnungen ausgeben.  
**Wie mit Warnungen umgehen:**  
- Wenn dein Projekt die API-Teile ben√∂tigt, die eine Warnung ausl√∂sen, musst du das zugrunde liegende Problem beheben.  
- Wenn du diese Endpunkte oder Features nicht ben√∂tigst, kannst du die Warnungen sicher ignorieren.
- F√ºr blockierende Probleme in der OpenAPI-Spezifikation melde diese bitte √ºber den [mittwald Feature Requests Tracker](https://github.com/mittwald/feature-requests).

Halte den Wartungsaufwand gering; vermeide es, die OpenAPI-Spezifikation zu patchen, es sei denn, es ist unbedingt notwendig. Bevorzuge Generator-Konfigurationsanpassungen.

### Den generierten Client installieren und testen

Nach der Generierung erscheint ein `mittwald-api-client`-Ordner in deinem Projektverzeichnis. Installiere ihn zum Testen:

```shellsession
(venv)(user@local) $ pip install -e ./mittwald-api-client
```

Schaue dir die generierte `mittwald-api-client/README.md` an, um loszulegen. Teste deinen Client mit echten Business Cases; hier ist ein Starter-Skript f√ºr eine einfache GET-Operation:

```python name=examples/python-client-get.py
import os
import sys
from dotenv import load_dotenv
from mittwald_api_client import AuthenticatedClient
from mittwald_api_client.api.project import project_get_server

def main():
    """Test freshly built API client: set up an authenticated client from environment and fetch server info."""
    load_dotenv()
    API_TOKEN = os.getenv("API_TOKEN")
    SERVER_ID = os.getenv("SERVER_ID")
    if API_TOKEN is None or SERVER_ID is None:
        print("API_TOKEN or SERVER_ID missing. Check environment.")
        sys.exit(1)
    client = AuthenticatedClient(
        base_url="https://api.mittwald.de",
        token=API_TOKEN,
        follow_redirects=True,  # API returns 308 redirects, not expected by client by default
    )
    with client as myclient:
        res = project_get_server.sync_detailed(
            client=myclient,
            server_id=SERVER_ID,
        )
    print("client call result:")
    print(res)
    print("---")

if __name__ == '__main__':
    main()
```

:::note
Es wird dringend empfohlen, Credentials und Kontext √ºber Umgebungsvariablen oder `.env`-Dateien zu verwalten, anstatt √ºber Kommandozeilen-Argumente oder Hardcoding. Dieses Beispiel verwendet `dotenv.load_dotenv`, um Credentials aus `.env` zu laden.
:::

```shellsession name=.env-example
# Example .env file for local development
API_TOKEN=your-api-token-here
SERVER_ID=your-server-id-here
```

:::warning
Committe niemals `.env` oder andere Secret-Dateien in die Versionskontrolle. Verwende `.gitignore`-Dateien, um solche Dateien von der Versionskontrolle auszuschlie√üen.
:::

:::note
F√ºr fortgeschrittene oder leistungsintensive Anwendungsf√§lle erw√§ge die Verwendung der Async-API, die in modernen Clients verf√ºgbar ist. Beginne synchron f√ºr Einfachheit; wechsle zu async, wenn n√∂tig.
:::

### Nicht-GET-Operationen testen ‚Äì Beispiel POST

Um andere HTTP-Methoden (POST, PATCH, DELETE) zu verwenden, musst du Request-Body-Objekte konstruieren. Hier ist ein Beispiel f√ºr eine POST-Operation:

```python name=examples/python-client-post.py
import os
import sys
import time

from dotenv import load_dotenv

from mittwald_api_client import AuthenticatedClient
from mittwald_api_client.api.project import project_create_project
from mittwald_api_client.models import ProjectCreateProjectBody


def main():
    """
    Test fresh built API client, set up authenticated client
    from environment and fetch server information
    """

    load_dotenv()

    API_TOKEN = os.getenv("API_TOKEN")
    SERVER_ID = os.getenv("SERVER_ID")

    if API_TOKEN is None or SERVER_ID is None:
        print("API_TOKEN or SERVER_ID missing. Check environment.")
        sys.exit(1)

    client = AuthenticatedClient(
        base_url="https://api.mittwald.de",
        token=API_TOKEN,
        follow_redirects=True,  # API returns 308 aka permanent redirects, NOT expected by client by default
    )

    with client as myclient:
        res = project_create_project.sync(
            client=myclient,
            server_id=SERVER_ID,
            body=ProjectCreateProjectBody.from_dict({
                "description": f"python_post_test_project_{time.time()}"
            })
        )

    print("client call result:")
    print(res)
    print("---")

if __name__ == '__main__':
    main()
```

Pr√ºfe die generierten Client-Modelle auf erforderliche Felder und Strukturen.

:::note
Stelle auch sicher, dass du ein Token mit Schreibberechtigungen verwendest, wenn du CRUD-Operationen √ºber die API ausf√ºhrst.
:::

## Nach der Generierung ‚Äì Aufr√§umen

- √úberpr√ºfe generierte Tests, README und Beispiel-Skripte, bevor du publizierst oder mit deiner Haupt-App integrierst.
- R√§ume nicht ben√∂tigte Dateien auf, damit klar und fokussiert ist, was du auslieferst.

## Package Naming ‚Äì Hinweis zu Konflikten

:::note
Generierte Package-Namen (wie `mittwald-api-client`) k√∂nnen mit bestehenden Packages in PyPI kollidieren. Bei Bedarf passe die Generator-Config oder den Package-Namen vor der Ver√∂ffentlichung an, um Konflikte zu vermeiden.
:::

## Python mittwald API Client ver√∂ffentlichen

Die Ver√∂ffentlichung von API-Clients h√§ngt von deinem Use Case ab; f√ºr hochspezialisierte Projekte ist eine Ver√∂ffentlichung m√∂glicherweise nicht erforderlich. F√ºr allgemeine oder wiederverwendbare Clients ist das √∂ffentliche PyPI der Standard.

Folge den Anweisungen in der generierten README f√ºr die Ver√∂ffentlichung. Beispiel f√ºr **test PyPI**:

```shellsession
poetry config repositories.testpypi https://test.pypi.org/simple/
poetry config pypi-token.testpypi <TOKEN-HERE>
cd mittwald-api-client
poetry publish --build -r testpypi
```

Nach erfolgreicher Ver√∂ffentlichung:

```shellsession
cd my-python-mittwald-project
pip install -i https://test.pypi.org/simple/ mittwald-api-client
```

> Die gleichen Schritte gelten f√ºr das produktive PyPI. Verwende eindeutige Package-Namen, um Konflikte zu vermeiden!

F√ºr Automatisierung und Wartung fahre bitte mit dem [Wartungs- & Pipeline-Abschnitt](#maintenance-pipeline) fort.

## Python API Client-Generierung und -Release mit GitHub Actions automatisieren

Um sicherzustellen, dass dein Python mittwald API Client immer auf dem neuesten Stand
mit den neuesten API-√Ñnderungen bleibt, kannst du eine CI/CD-Pipeline mit GitHub Actions
einrichten. Dieser Workflow wird automatisch den Client aus der OpenAPI-Spezifikation
regenerieren, testen und ‚Äì optional ‚Äì neue Versionen nach einem regelm√§√üigen Zeitplan
(z. B. w√∂chentlich) ver√∂ffentlichen.

### Voraussetzungen

- Dein Projekt-Repository auf GitHub.
- Python 3.8+ in deinem Workflow spezifiziert.
- Zugang zur mittwald OpenAPI-Spezifikations-URL.
- Publishing-Credentials (z. B. PyPI-Token) als GitHub-Repository-Secrets gespeichert.

### Erforderliche Dateien zum Repo hinzuf√ºgen

- Platziere deine Generator-Config-Datei (z. B. `.openapi-python-client-config.yml`) im Projekt-Root, falls erforderlich.
- Behalte deine Test-Skripte und Beispiel-`.env.example`-Dateien eingecheckt, aber committe **niemals** echte Credentials.

### Beispiel GitHub Actions Workflow

Erstelle eine Datei unter `.github/workflows/client-release.yml`:

```yaml name=.github/workflows/client-release.yml
name: API Client Regeneration and Release

permissions:
  contents: write
  id-token: write       # Required for OIDC with PyPI trusted publisher

on:
  schedule:
    - cron: '0 4 * * 1'       # Runs every Monday at 04:00 UTC
  workflow_dispatch:           # Allows manual trigger

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4   # v4 is latest stable at time of writing
        with:
          fetch-depth: 0   # Fetch all history and tags

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Upgrade pip, install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements_build.txt

      - name: Download OpenAPI specification
        run: curl --location --fail --silent 'https://api.mittwald.de/v2/openapi.json' > openapi.json

      - name: Filter deprecated endpoints from OpenAPI spec
        run: |
          echo "Filtering specs ..."
          python tools/filter_openapi_deprecated.py openapi.json openapi.json

      - name: Set dynamic version in OpenAPI spec
        run: |
          LAST_TAG=$(git tag --sort=-creatordate | head -n 1)
          python tools/adjust_openapi_version.py openapi.json $LAST_TAG

      - name: Regenerate Client
        run: openapi-python-client generate --overwrite --path ./openapi.json

      - name: Install Generated Client for Testing
        run: pip install -e ./mittwald-api-client

      - name: Run Tests
        run: |
          python smoke_test.py

      - name: Extract version from openapi.json
        id: get_version
        run: |
          VERSION=$(jq -r '.info.version' openapi.json)
          echo "RELEASE_VERSION=$VERSION" >> $GITHUB_ENV

      - name: Commit regenerated client
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git add mittwald-api-client openapi.json
          git commit -m "chore: update generated API client ${RELEASE_VERSION}" || echo "No changes to commit"
          git push origin HEAD:${{ github.ref }}

      - name: Build Package
        run: |
          cd mittwald-api-client
          poetry build

      - name: List build output
        run: |
          cd mittwald-api-client
          ls -la dist

      - name: Publish to TestPyPI using OIDC
        if: ${{ github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' }}
        uses: pypa/gh-action-pypi-publish@v1.13.0
        with:
          repository-url: https://test.pypi.org/legacy/
          packages-dir: mittwald-api-client/dist
          verbose: true

      - name: Create and push git tag
        if: success()
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git tag "v$RELEASE_VERSION"
          git push origin "v$RELEASE_VERSION"
        env:
          RELEASE_VERSION: ${{ env.RELEASE_VERSION }}

      - name: Upload built packages for inspection
        uses: actions/upload-artifact@v4
        with:
          name: built-dist
          path: mittwald-api-client/dist/
```

### Best Practices und Tipps

- **Zeitplan weise w√§hlen:**  
  Verwende die `cron`-Scheduling-Syntax, um zu steuern, wie h√§ufig Releases stattfinden (z. B. w√∂chentlich, t√§glich).
- **Secrets sichern:**  
  Konfiguriere deinen Workflow als Trusted Publisher auf PyPI und verwende die moderne `gh-action-pypi-publish`-Action. Dies ist die aktuelle Methode, um sichere und tokenlose Release-Pipelines zu erstellen.
- **Testing:**  
  Teste den regenerierten Client immer vor der Ver√∂ffentlichung. F√ºge aussagekr√§ftige Business-Case-Tests hinzu, um zu verhindern, dass defekte Packages ver√∂ffentlicht werden.
- **Manuelle Trigger:**  
  Das `workflow_dispatch`-Event erm√∂glicht es Maintainern, Releases bei Bedarf auszul√∂sen.
- **Versionskontrolle:**  
  Erw√§ge, Releases zu taggen oder Versionsnummern basierend auf API-/Spec-√Ñnderungen zu aktualisieren.
- **Artifact-Upload:**
  F√ºge einen `upload-artifact`-Schritt hinzu, um Build-Output f√ºr Debugging und Inspektion zu bewahren.

---

### Den Workflow erweitern

- Du kannst Schritte hinzuf√ºgen, um automatisch Release Notes, Tags oder Changelogs zu erstellen.
- Unterst√ºtze mehrere Python-Versionen durch Matrix-Builds, falls erforderlich.
- Integriere Benachrichtigungen oder Fehlschlag-Alarme √ºber Slack, E-Mail, etc.

Mit diesem Setup bleibt dein API-Client aktuell, getestet und einfach verteilbar ‚Äì ohne manuelle Intervention.
