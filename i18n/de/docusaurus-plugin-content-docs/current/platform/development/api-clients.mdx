---
title: API-Clients erstellen
sidebar_label: API-Clients erstellen
description: Guide f√ºr die Erstellung eigner API-Clients aus der OpenAPI Spezifikation
---

# Einf√ºhrung {#intro}

Bei der Arbeit mit der mittwald-API gibt es viele Gr√ºnde, warum du
einen eigenen API-Client erstellen m√∂chtest ‚Äì oder sogar musst ‚Äì,
anstatt ausschlie√ülich auf offizielle SDKs zu setzen. W√§hrend
Sprachpr√§ferenzen und die Einhaltung von Unternehmensstandards h√§ufige
Beweggr√ºnde sind, gibt es mehrere zus√§tzliche Faktoren, die du
ber√ºcksichtigen solltest:

- **Programmiersprache und Technology Stack**  
  Nicht alle Sprachen oder Plattformen verf√ºgen √ºber ein offizielles SDK.
  Wenn dein Projekt eine Sprache, ein Framework oder eine Umgebung verwendet,
  die nicht von Haus aus unterst√ºtzt wird, sorgt ein eigener Client f√ºr eine
  reibungslose Integration.

- **Erweiterte oder nicht standardm√§√üige Authentifizierungsabl√§ufe**  
  Einige Projekte erfordern flexible Authentifizierungsmethoden: die Verwendung
  von Tokens aus Umgebungsvariablen, die Sicherung von Extension-Interaktionen,
  die Handhabung von Session-Tokens in Browser-Szenarien oder die automatische
  Rotation von Secrets. Offizielle Clients decken m√∂glicherweise nicht alle neuen
  oder komplexen organisationsspezifischen Authentifizierungsanforderungen ab.

- **Integration in spezialisierte Umgebungen**  
  Von CLI-Tools √ºber browserbasierte Apps, Serverless-Funktionen bis hin zu
  eingebetteten Systemen ‚Äì Plattform- und Laufzeitbeschr√§nkungen erfordern manchmal
  ma√ügeschneiderte Clients, die f√ºr ihre spezifische Umgebung optimiert sind.

- **Anpassungsf√§higkeit an API-√Ñnderungen und experimentelle Features**  
  APIs entwickeln sich weiter ‚Äì manchmal schnell. Das Erstellen eines eigenen Clients
  kann dir helfen, Beta-Features zu nutzen, mit Endpunkten zu arbeiten, die noch nicht
  offiziell unterst√ºtzt werden, oder dich schnell an Breaking Changes oder
  herstellerspezifische Erweiterungen anzupassen.

- **Architektonische und Integrationsflexibilit√§t**  
  Teams mit fortgeschrittenen Architekturmustern (wie Microservices, Middleware-Layering
  oder Plugin-Systemen) ben√∂tigen oft mehr Kontrolle, wie z. B. das Einf√ºgen von
  benutzerdefiniertem Logging, Tracing oder Rate-Limiting auf Client-Ebene oder die
  Zusammensetzung h√∂herwertiger Abstraktionen √ºber dem API-Transport.

- **Sicherheit, Compliance und Auditing**  
  Bestimmte Branchen und Organisationen verlangen, dass Code vollst√§ndig auditierbar
  oder selbst gehostet ist, sich eng in interne Sicherheitstools integriert oder
  Credentials auf benutzerdefinierte Weise verwaltet. Das Erstellen eines eigenen
  Clients erm√∂glicht es dir, diese Anforderungen zu erf√ºllen.

- **Testing, Mocking und lokale Entwicklung**  
  Eigene Clients k√∂nnen Features enthalten, die f√ºr lokale Entwicklung und CI n√ºtzlich
  sind, wie Mock-Datenmodi, Test-Doubles oder vereinfachte Authentifizierung f√ºr
  fr√ºhes Prototyping, ohne sensible Credentials preiszugeben.

- **Dokumentation, Lokalisierung und Onboarding**  
  Manchmal ist ein eigener Client ein strategisches Asset: Er kann in der Muttersprache
  des Teams geschrieben und dokumentiert werden oder mit Onboarding-Beispielen und
  Anleitungen f√ºr die Entwickler deiner Organisation ma√ügeschneidert werden.

- **Dependency Management und Code Ownership**  
  Ein eigener Client erm√∂glicht es dir, Dependencies zu pinnen, die API-Oberfl√§che an
  deine Bed√ºrfnisse anzupassen und externe Drift zu vermeiden ‚Äì entscheidend f√ºr
  Organisationen mit strengen Stabilit√§ts- oder Sicherheitsstandards.

**Zusammenfassend:**  
Eigene API-Clients sind nicht nur eine Frage pers√∂nlicher oder Unternehmenspr√§ferenzen ‚Äì
sie sind ein wichtiger Enabler f√ºr Integration, Compliance, Sicherheit und
Entwicklerproduktivit√§t.

Indem du einen auf deine spezifischen Anforderungen zugeschnittenen Client entwickelst,
stellst du sicher, dass deine Anwendungen robust, wartbar und zukunftssicher bleiben.

# Vorbereitung {#preparation}

Eine gr√ºndliche Vorbereitung ist die Grundlage f√ºr einen reibungslosen und effizienten
Entwicklungsprozess f√ºr eigene API-Clients.

Mit der richtigen Vorarbeit ist es oft m√∂glich, den Gro√üteil deines Clients automatisch
zu generieren, mit minimaler manueller Intervention. Im Folgenden sind wichtige
Vorbereitungsbereiche aufgef√ºhrt, die du vor dem Start ber√ºcksichtigen solltest:

## Verstehe deinen Use Case und die Zielumgebung {#use-case-and-goal}

- **Wo wird der Client ausgef√ºhrt?**  
  Identifiziere, ob dein Client in serverseitigen Apps, browserbasierten Skripten,
  Kommandozeilen-Tools, Serverless-Funktionen oder CI/CD-Pipelines verwendet wird.
- **Wer sind die Endnutzer?**  
  Ber√ºcksichtige interne Teams, externe Kunden oder Automatisierungstools, da dies
  Features und Benutzerfreundlichkeit beeinflusst.
- **Gibt es Plattformbeschr√§nkungen?**  
  Einige Umgebungen (wie Browser oder Serverless) k√∂nnen Einschr√§nkungen bei
  Authentifizierungsmethoden, Storage oder Dependencies haben.

## Sammle und √ºberpr√ºfe die OpenAPI-Spezifikation {#get-openapi-specification}

Lade die aktuelle OpenAPI-Spezifikation f√ºr die API herunter:

```shellsession
user@local $ curl --location --fail --silent 'https://api.mittwald.de/v2/openapi.json' > openapi.json
```

- **Validiere die Spezifikation:**  
  Verwende OpenAPI-Validatoren (z. B. [Swagger Editor](https://editor.swagger.io/)),
  um auf Fehler oder Inkonsistenzen zu pr√ºfen.
- **Pr√ºfe auf Vollst√§ndigkeit:**  
  Stelle sicher, dass alle erforderlichen Endpunkte, Authentifizierungsabl√§ufe und
  Schemas dokumentiert sind.

## Kl√§re Authentifizierungs- und Sicherheitsanforderungen {#authentication-and-security}

- **Authentifizierungsmethoden:**  
  Muss dein Client API-Tokens, OAuth2, Extension-Secrets oder zus√§tzliche Mechanismen
  unterst√ºtzen?
- **Secret Management:**  
  Stelle sicher, dass erforderliche Tokens oder Secrets verf√ºgbar sind und sicher
  eingebunden werden k√∂nnen (z. B. √ºber Umgebungsvariablen, Config-Dateien, sichere Vaults).
- **Plane f√ºr sichere Speicherung:**  
  Hardcode niemals sensible Informationen im Client.

## W√§hle und richte deine Code-Generierungstools ein {#code-generator}

- **W√§hle einen Code-Generator:**  
  Tools wie [OpenAPI Generator](https://openapi-generator.tech/),
  [Swagger Codegen](https://github.com/swagger-api/swagger-codegen) oder
  [Autorest](https://aka.ms/autorest) k√∂nnen Clients in vielen Sprachen erstellen.
- **Pr√ºfe die Kompatibilit√§t:**  
  Stelle sicher, dass dein gew√§hltes Tool deine bevorzugte Sprache und die
  bereitgestellte OpenAPI-Version unterst√ºtzt.
- **Installiere den Generator:**  
  Richte das Codegen-Toolkit ein und mache dich mit seinen Optionen und
  Konfigurationsdateien vertraut.

## Bereite Generator- und Projektkonfiguration vor {#code-generator-config}

- **Passe Generator-Einstellungen an:**  
  Konfiguriere Type-Mappings, Serialisierungsoptionen, HTTP-Client-Auswahl,
  Package-Naming und Code-Style entsprechend den Konventionen deines Projekts.
- **Unterst√ºtzende Dateien:**  
  Bereite Konfigurationen/Templates f√ºr Umgebungsvariablen, CI-Skripte,
  Dokumentation und Testing vor.
- **Versionierungs-Setup:**  
  Entscheide, wie dein Client die API-Version widerspiegeln soll ‚Äì dies hilft
  Konsumenten, die API-Kompatibilit√§t zu verstehen.

## Plane f√ºr API-Evolution und Wartung {#api-evolution-and-maintenance}

- **Automatisiere Updates:**  
  Erw√§ge, den gesamten Fetch-Generate-Test-Prozess zu skripten, damit dein Client
  mit der API-Evolution Schritt h√§lt.
- **√úberwache API-√Ñnderungen:**  
  Abonniere API-Changelogs und sei bereit, bei √Ñnderungen der OpenAPI-Spezifikation
  neu zu generieren und zu testen.
- **Handhabung von Breaking Changes:**  
  Richte eine Versionskontrolle ein und plane, wie du Client-Updates verwaltest,
  wenn die API-Struktur aktualisiert wird.

## Identifiziere spezielle API-Features und Custom Logic {#custom-logic}

- **Spezielle Endpunkte:**  
  Beachte, ob die API Pagination, File-Uploads, Webhooks, lang laufende Operationen
  oder andere fortgeschrittene Patterns enth√§lt. Code-Generatoren erfordern
  m√∂glicherweise zus√§tzliche Konfiguration oder manuelle Anpassungen daf√ºr.
- **Fehlerbehandlung:**  
  Pr√ºfe auf konsistente Fehlerantwortformate und plane, wie der generierte Client
  diese anzeigen soll.
- **Eigene Workflows:**  
  Wenn bestimmte Business-Flows zusammengesetzte oder mehrstufige API-Interaktionen
  erfordern, dokumentiere diese Szenarien, um den Client nach der Generierung zu erweitern.

Durch gr√ºndliche Vorbereitung entlang dieser Linien beschleunigst du nicht nur den
initialen Client-Build, sondern stellst auch sicher, dass deine L√∂sung robust, sicher
und wartbar bleibt, w√§hrend sich sowohl deine Codebasis als auch die mittwald-API
weiterentwickeln.

## Arbeiten mit OpenAPI Overlays {#openapi-overlays}

Um reproduzierbare Ergebnisse zu erzeugen und Anpassungsschritte sogar teilen zu k√∂nnen, sind [OpenAPI Overlays](https://learn.openapis.org/overlay/)
eine gute M√∂glichkeit, die Basis-OpenAPI-Spezifikation auf eine wartbare Weise anzupassen.

Anstatt generierte Clients oder die Mittwald OpenAPI-Spezifikation manuell zu ver√§ndern,
erstellen wir ein Overlay mit Patch-Operationen, das dann auf die Original-
Spezifikation angewendet werden kann, um Anpassungen vorzunehmen.

Diese Overlays k√∂nnen gespeichert und wiederverwendet werden; in manchen Anwendungsf√§llen werden sogar mehrere Overlays
hintereinander verwendet, zum Beispiel werden zuerst unerw√ºnschte Operationen entfernt, anschlie√üend das `description`-
Feld f√ºr die ben√∂tigten Operationen √ºbersetzt.

Im folgenden Python-Beispiel wird diese Toolchain verwendet, um jegliches manuelles Filtern
oder Anpassen der Spezifikation vollst√§ndig zu vermeiden und einen vollst√§ndig generierten Client aus reproduzierbaren
Quellen zu erstellen.

# Philosophie {#philosophy}

Ein reibungsloser Entwicklungsworkflow basiert auf der Arbeit mit zuverl√§ssigen,
standardkonformen Tools und Spezifikationen. Beim Erstellen eigener API-Clients aus
OpenAPI-Spezifikationen solltest du vor allem auf Einfachheit und Wartbarkeit achten.

**Lass den Generator die Arbeit machen:**  
Moderne OpenAPI-Client-Generatoren sind leistungsstark und bew√§ltigen die meisten
typischen API-Komplexit√§ten automatisch. In den meisten F√§llen sollte minimale
Konfiguration oder manuelle Intervention notwendig sein, vorausgesetzt, die
API-Spezifikation ist gut gepflegt.

Wenn du auf Einschr√§nkungen oder Eigenheiten st√∂√üt ‚Äì wie subtile Warnungen,
Versionsunterschiede oder Abweichungen vom OpenAPI-Standard ‚Äì priorisiere die
Behebung der Grundursache, idealerweise durch Verbesserung oder Korrektur der
Spezifikation selbst. Das [Melden von Problemen](https://github.com/mittwald/feature-requests/issues)
oder das Einbringen von Fixes zur API-Spezifikation hilft der Community und verbessert die Ergebnisse f√ºr alle.

**Vermeide unn√∂tige Komplexit√§t:**  
Versuche, darauf zu verzichten, Workarounds oder eigene Patches f√ºr jeden Edge Case
in generierten Clients einzuf√ºhren. Die Konzentration auf Generator-Konfiguration,
anstatt auf manuelle Code-√Ñnderungen oder Ad-hoc-"Fixes" an der Spezifikation,
h√§lt deinen Workflow nachhaltig und zukunftssicher.

:::tip
üå± **Pflege deinen Generierungsprozess, nicht das Output.**  
Investiere deine manuellen Bem√ºhungen in die Verbesserung von Automatisierung, Testing und Pipeline-Robustheit ‚Äì statt in aufw√§ndige Bearbeitungen von generiertem Code.
:::

Zu den beliebten OpenAPI-Generatoren geh√∂ren [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) und andere. Teste generierte Clients mit einfachen API-Requests, um schnell zu validieren, dass sie wie erwartet funktionieren.

**Fazit:**  
Ein wenig Disziplin bei der Pflege eines sauberen, automatisierten Generierungs-Workflows
reduziert nicht nur technische Schulden, sondern spart dir und deinem Team Zeit bei
jedem neuen API-Release.

# Beispiel ‚Äì Python API Client {#example-python}

**Anforderungen:**
- Python-Installation (Version 3.10+ empfohlen)
- Grundkenntnisse in Bash, Python, `pip` und virtuellen Umgebungen

Ein Python-API-Client kann mit dem [openapi-python-client-Modul](https://github.com/openapi-generators/openapi-python-client) generiert werden.

Da der Client selbst zu 100% generiert wird, konzentrieren wir uns auf die Erstellung
einer **Pipeline** f√ºr automatisierte Client-Erstellung, Release und Updates. Im
Folgenden beginnen wir mit dem manuellen Prozess zur Veranschaulichung ‚Äì Automatisierung
und Wartung werden im n√§chsten Abschnitt behandelt.

## Einen Python mittwald API Client erstellen {#create-python-client}

Bevor du den Workflow automatisierst, beginne damit, manuell einen Client in deiner
Konsole zu generieren. Erstelle zun√§chst deinen Projektordner, richte eine virtuelle
Python-Umgebung ein und installiere den Client-Generator:

```shellsession
user@local $ mkdir python-api-client
user@local $ cd python-api-client
user@local $ python3 -m venv venv
user@local $ source venv/bin/activate
(venv) user@local $ pip install openapi-python-client python-dotenv
```

:::note
`(venv)` zeigt an, dass deine virtuelle Umgebung aktiv ist. Dies √§ndert deinen `PATH`,
sodass `python` auf den lokalen Interpreter zeigt. Die Aktivierung f√ºr bash/zsh wird
gezeigt; f√ºr andere Shells (PowerShell, fish, etc.) siehe `venv/bin/`. Deaktivierung
mit `deactivate`. Unter Windows ist die Aktivierung `venv\Scripts\activate`.
:::

### Die OpenAPI-Spezifikation herunterladen {#fetch-openapi-specs}

```shellsession
user@local $ curl --location --fail --silent 'https://api.mittwald.de/v2/openapi.json' > openapi.json
```

:::note
Um zu vermeiden, dass der generierte Client mit zu vielen Operationen √ºberladen wird,
kann es hilfreich sein, die OpenAPI-Spezifikation vor der Clientgenerierung zu filtern.
Dies umfasst das Filtern veralteter Operationen, die andernfalls im Client als Platzhalter erscheinen k√∂nnten.
:::

### (Optional) Spezifikation per Overlay anpassen {#adjust-openapi-overlays}

Auch wenn du die rohe OpenAPI-Spezifikation direkt verwenden kannst um einen API-Client
zu erstellen, ist es oft sinnvoll, die Basis-Spezifikation vorher anzupassen,
um einen individuelleren Client zu erzeugen.

Da Overlays deklarativ sind, kann es je nach Anwendungsfall notwendig sein,
eigene Logik zu verwenden, um diese Overlays zu generieren.

:::note
Overlays kannst du speichern und mehrfach oder in Kombination anwenden.
Bewahre sowohl die generierten Overlays **als auch** die Basis-Spezifikation als Build-Artefakte auf,
damit du sp√§ter reproduzierbare Builds erstellen kannst.

Vergib verst√§ndliche Titel f√ºr deine Overlays und beschreibe sie pr√§zise.
Das erleichtert sp√§tere Audits und die Fehlersuche.
:::

Hier ein Beispiel f√ºr ein Overlay:

```json
{
  "overlay": "1.1.0",
  "info": {
    "title": "Overlay: Entferne veraltete und unerw√ºnschte Operationen",
    "version": "1.0.0",
    "description": "Entfernt veraltete Operationen und ‚Äì falls Tags angegeben sind ‚Äì nicht passende Operationen; l√∂scht leere Pfade. Siehe overlay_generator.py f√ºr die Business-Logik."
  },
  "actions": [
    {
      "target": "$.paths['/v2/appinstallations/{appInstallationId}/actions/{action}'].post",
      "remove": true,
      "description": "Wurde wegen Veralterung oder Filter entfernt"
    }
  ]
}
```

Die Herausforderung beim Erstellen von Overlays ist es, die passenden [JSONPath](https://www.rfc-editor.org/rfc/rfc9535.pdf) 
Selektoren f√ºr das `target`-Feld in den Aktionen zu bestimmen.

:::warning
Wie viele und welche Selektoren genutzt werden k√∂nnen, h√§ngt vom verwendeten Patch-Tool ab.
Wenn du einen breiten Selektor verwendest, der mehrere Elemente trifft, ist es m√∂glich,
dass das Tool nur das erste Element anpasst.

W√§hle Selektoren, die exakt ein Element treffen, und sei dabei so spezifisch wie m√∂glich.
Das hilft, Fehler und unerw√ºnschte Nebenwirkungen bei √Ñnderungen zu vermeiden.
Besonders bei vielen Anpassungen sollten Overlays mit einem Skript generiert werden und nicht von Hand.
:::

Beispiel f√ºr das Anwenden eines Overlays mit [oas-patcher](https://github.com/mcroissant/oas_patcher):

```shellsession
# Overlay-Generator erstellt "openapi_filter_overlay.json"
python tools/overlay_generator.py openapi.json openapi_filter_overlay.json

# Overlay anwenden, erstellt "openapi_from_overlay.json"
oas-patch overlay openapi.json openapi_filter_overlay.json -o openapi_from_overlay.json
```

Die resultierende `openapi_from_overlay.json` ist entsprechend den im `openapi_filter_overlay.json`
definierten Aktionen gefiltert. Halte diese Dateien zusammen mit der Basis-`openapi.json` bereit,
um Builds sp√§ter exakt reproduzieren zu k√∂nnen.

### Den Code-Generator ausf√ºhren {#run-generator}

```shellsession
(venv) user@local $ openapi-python-client generate --path ./openapi.json
```

Der Generator kann Warnungen ausgeben.  
**Wie mit Warnungen umgehen:**  
- Wenn dein Projekt die API-Teile ben√∂tigt, die eine Warnung ausl√∂sen, musst du das zugrunde liegende Problem beheben.  
- Wenn du diese Endpunkte oder Features nicht ben√∂tigst, kannst du die Warnungen sicher ignorieren.
- F√ºr blockierende Probleme in der OpenAPI-Spezifikation melde diese bitte √ºber den [mittwald Feature Requests Tracker](https://github.com/mittwald/feature-requests).

Halte den Wartungsaufwand gering; vermeide es, die OpenAPI-Spezifikation zu patchen, es sei denn, es ist unbedingt notwendig. Bevorzuge Generator-Konfigurationsanpassungen.

### Den generierten Client installieren und testen {#install-client}

Nach der Generierung erscheint ein `mittwald-api-client`-Ordner in deinem Projektverzeichnis. Installiere ihn zum Testen:

```shellsession
(venv) user@local $ pip install -e ./mittwald-api-client
```

Schaue dir die generierte `mittwald-api-client/README.md` an, um loszulegen. Teste deinen Client mit echten Business Cases; hier ist ein Starter-Skript f√ºr eine einfache GET-Operation:

```python name=examples/python-client-get.py
import os
import sys
from dotenv import load_dotenv
from mittwald_api_client import AuthenticatedClient
from mittwald_api_client.api.project import project_get_server

def main():
    """Test freshly built API client: set up an authenticated client from environment and fetch server info."""
    load_dotenv()
    API_TOKEN = os.getenv("API_TOKEN")
    SERVER_ID = os.getenv("SERVER_ID")
    if API_TOKEN is None or SERVER_ID is None:
        print("API_TOKEN or SERVER_ID missing. Check environment.")
        sys.exit(1)
    client = AuthenticatedClient(
        base_url="https://api.mittwald.de",
        token=API_TOKEN,
        follow_redirects=True,  # API returns 308 redirects, not expected by client by default
    )
    with client as myclient:
        res = project_get_server.sync_detailed(
            client=myclient,
            server_id=SERVER_ID,
        )
    print("client call result:")
    print(res)
    print("---")

if __name__ == '__main__':
    main()
```

:::note
Es wird dringend empfohlen, Credentials und Kontext √ºber Umgebungsvariablen oder `.env`-Dateien zu verwalten, anstatt √ºber Kommandozeilen-Argumente oder Hardcoding. Dieses Beispiel verwendet `dotenv.load_dotenv`, um Credentials aus `.env` zu laden.
:::

```text
# Example .env file for local development
API_TOKEN=your-api-token-here
SERVER_ID=your-server-id-here
```

:::warning
Committe niemals `.env` oder andere Secret-Dateien in die Versionskontrolle. Verwende `.gitignore`-Dateien, um solche Dateien von der Versionskontrolle auszuschlie√üen.
:::

:::note
F√ºr fortgeschrittene oder leistungsintensive Anwendungsf√§lle erw√§ge die Verwendung der Async-API, die in modernen Clients verf√ºgbar ist. Beginne synchron f√ºr Einfachheit; wechsle zu async, wenn n√∂tig.
:::

### Nicht-GET-Operationen testen ‚Äì Beispiel POST {#post-example}

Um andere HTTP-Methoden (POST, PATCH, DELETE) zu verwenden, musst du Request-Body-Objekte konstruieren. Hier ist ein Beispiel f√ºr eine POST-Operation:

```python name=examples/python-client-post.py
import os
import sys
import time

from dotenv import load_dotenv

from mittwald_api_client import AuthenticatedClient
from mittwald_api_client.api.project import project_create_project
from mittwald_api_client.models import ProjectCreateProjectBody


def main():
    """
    Test fresh built API client, set up authenticated client
    from environment and fetch server information
    """

    load_dotenv()

    API_TOKEN = os.getenv("API_TOKEN")
    SERVER_ID = os.getenv("SERVER_ID")

    if API_TOKEN is None or SERVER_ID is None:
        print("API_TOKEN or SERVER_ID missing. Check environment.")
        sys.exit(1)

    client = AuthenticatedClient(
        base_url="https://api.mittwald.de",
        token=API_TOKEN,
        follow_redirects=True,  # API returns 308 aka permanent redirects, NOT expected by client by default
    )

    with client as myclient:
        res = project_create_project.sync(
            client=myclient,
            server_id=SERVER_ID,
            body=ProjectCreateProjectBody.from_dict({
                "description": f"python_post_test_project_{time.time()}"
            })
        )

    print("client call result:")
    print(res)
    print("---")

if __name__ == '__main__':
    main()
```

Pr√ºfe die generierten Client-Modelle auf erforderliche Felder und Strukturen.

:::note
Stelle auch sicher, dass du ein Token mit Schreibberechtigungen verwendest, wenn du CRUD-Operationen √ºber die API ausf√ºhrst.
:::

## Nach der Generierung ‚Äì Aufr√§umen {#clean-up}

- √úberpr√ºfe generierte Tests, README und Beispiel-Skripte, bevor du publizierst oder mit deiner Haupt-App integrierst.
- R√§ume nicht ben√∂tigte Dateien auf, damit klar und fokussiert ist, was du auslieferst.

## Package Naming ‚Äì Hinweis zu Konflikten {#naming-conflicts}

:::note
Generierte Package-Namen (wie `mittwald-api-client`) k√∂nnen mit bestehenden Packages in PyPI kollidieren. Bei Bedarf passe die Generator-Config oder den Package-Namen vor der Ver√∂ffentlichung an, um Konflikte zu vermeiden.
:::

## Python mittwald API Client ver√∂ffentlichen {#publish-client}

Die Ver√∂ffentlichung von API-Clients h√§ngt von deinem Use Case ab; f√ºr hochspezialisierte Projekte ist eine Ver√∂ffentlichung m√∂glicherweise nicht erforderlich. F√ºr allgemeine oder wiederverwendbare Clients ist das √∂ffentliche PyPI der Standard.

Folge den Anweisungen in der generierten README f√ºr die Ver√∂ffentlichung. Beispiel f√ºr **test PyPI**:

```shellsession
(venv) user@local $ poetry config repositories.testpypi https://test.pypi.org/simple/
(venv) user@local $ poetry config pypi-token.testpypi <TOKEN-HERE>
(venv) user@local $ cd mittwald-api-client
(venv) user@local $ poetry publish --build -r testpypi
```

Nach erfolgreicher Ver√∂ffentlichung:

```shellsession
(venv) user@local $ cd my-python-mittwald-project
(venv) user@local $ pip install -i https://test.pypi.org/simple/ mittwald-api-client
```

:::note
Die gleichen Schritte gelten f√ºr das produktive PyPI. Verwende eindeutige Package-Namen, um Konflikte zu vermeiden!
:::

F√ºr Automatisierung und Wartung fahre bitte mit dem [Wartungs- & Pipeline-Abschnitt](#maintenance-pipeline) fort.

## Python API Client-Generierung und -Release mit GitHub Actions automatisieren {#maintenance-pipeline}

Um sicherzustellen, dass dein Python mittwald API Client immer auf dem neuesten Stand
mit den neuesten API-√Ñnderungen bleibt, kannst du eine CI/CD-Pipeline mit GitHub Actions
einrichten. Dieser Workflow wird automatisch den Client aus der OpenAPI-Spezifikation
regenerieren, testen und ‚Äì optional ‚Äì neue Versionen nach einem regelm√§√üigen Zeitplan
(z. B. w√∂chentlich) ver√∂ffentlichen.

### Voraussetzungen {#pipeline-requirements}

- Dein Projekt-Repository auf GitHub.
- Python 3.10+ in deinem Workflow spezifiziert.
- Zugang zur mittwald OpenAPI-Spezifikations-URL.
- Publishing-Credentials (z. B. PyPI-Token) als GitHub-Repository-Secrets gespeichert.

### Erforderliche Dateien zum Repo hinzuf√ºgen {#pipeline-config}

- Platziere deine Generator-Config-Datei (z. B. `.openapi-python-client-config.yml`) im Projekt-Root, falls erforderlich.
- Behalte deine Test-Skripte und Beispiel-`.env.example`-Dateien eingecheckt, aber committe **niemals** echte Credentials.

### Beispiel GitHub Actions Workflow {#example-workflow}

Erstelle eine Datei unter `.github/workflows/client-release.yml`:

```yaml name=.github/workflows/client-release.yml
name: API Client Regeneration and Release

permissions:
  contents: write
  id-token: write       # Required for OIDC with PyPI trusted publisher

on:
  schedule:
    - cron: '0 4 * * 1'       # Runs every Monday at 04:00 UTC
  workflow_dispatch:           # Allows manual trigger

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4   # v4 is latest stable at time of writing
        with:
          fetch-depth: 0   # Fetch all history and tags

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Upgrade pip, install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements_build.txt

      - name: Download OpenAPI specification
        run: curl --location --fail --silent 'https://api.mittwald.de/v2/openapi.json' > openapi.json

      - name: Filter deprecated endpoints from OpenAPI spec
        run: |
          echo "Filtering specs ..."
          python tools/filter_openapi_deprecated.py openapi.json openapi.json

      - name: Set dynamic version in OpenAPI spec
        run: |
          LAST_TAG=$(git tag --sort=-creatordate | head -n 1)
          python tools/adjust_openapi_version.py openapi.json $LAST_TAG

      - name: Regenerate Client
        run: openapi-python-client generate --overwrite --path ./openapi.json

      - name: Install Generated Client for Testing
        run: pip install -e ./mittwald-api-client

      - name: Run Tests
        run: |
          python smoke_test.py

      - name: Extract version from openapi.json
        id: get_version
        run: |
          VERSION=$(jq -r '.info.version' openapi.json)
          echo "RELEASE_VERSION=$VERSION" >> $GITHUB_ENV

      - name: Commit regenerated client
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git add mittwald-api-client openapi.json
          git commit -m "chore: update generated API client ${RELEASE_VERSION}" || echo "No changes to commit"
          git push origin HEAD:${{ github.ref }}

      - name: Build Package
        run: |
          cd mittwald-api-client
          poetry build

      - name: List build output
        run: |
          cd mittwald-api-client
          ls -la dist

      - name: Publish to TestPyPI using OIDC
        if: ${{ github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' }}
        uses: pypa/gh-action-pypi-publish@v1.13.0
        with:
          repository-url: https://test.pypi.org/legacy/
          packages-dir: mittwald-api-client/dist
          verbose: true

      - name: Create and push git tag
        if: success()
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git tag "v$RELEASE_VERSION"
          git push origin "v$RELEASE_VERSION"
        env:
          RELEASE_VERSION: ${{ env.RELEASE_VERSION }}

      - name: Upload built packages for inspection
        uses: actions/upload-artifact@v4
        with:
          name: built-dist
          path: mittwald-api-client/dist/
```

### Best Practices und Tipps {#best-practices}

- **Zeitplan weise w√§hlen:**  
  Verwende die `cron`-Scheduling-Syntax, um zu steuern, wie h√§ufig Releases stattfinden (z. B. w√∂chentlich, t√§glich).
- **Secrets sichern:**  
  Konfiguriere deinen Workflow als Trusted Publisher auf PyPI und verwende die moderne `gh-action-pypi-publish`-Action. Dies ist die aktuelle Methode, um sichere und tokenlose Release-Pipelines zu erstellen.
- **Testing:**  
  Teste den regenerierten Client immer vor der Ver√∂ffentlichung. F√ºge aussagekr√§ftige Business-Case-Tests hinzu, um zu verhindern, dass defekte Packages ver√∂ffentlicht werden.
- **Manuelle Trigger:**  
  Das `workflow_dispatch`-Event erm√∂glicht es Maintainern, Releases bei Bedarf auszul√∂sen.
- **Versionskontrolle:**  
  Erw√§ge, Releases zu taggen oder Versionsnummern basierend auf API-/Spec-√Ñnderungen zu aktualisieren.
- **Artifact-Upload:**
  F√ºge einen `upload-artifact`-Schritt hinzu, um Build-Output f√ºr Debugging und Inspektion zu bewahren.

### Den Workflow erweitern {#extend-workflow}

- Du kannst Schritte hinzuf√ºgen, um automatisch Release Notes, Tags oder Changelogs zu erstellen.
- Unterst√ºtze mehrere Python-Versionen durch Matrix-Builds, falls erforderlich.
- Integriere Benachrichtigungen oder Fehlschlag-Alarme √ºber Slack, E-Mail, etc.

Mit diesem Setup bleibt dein API-Client aktuell, getestet und einfach verteilbar ‚Äì ohne manuelle Intervention.
