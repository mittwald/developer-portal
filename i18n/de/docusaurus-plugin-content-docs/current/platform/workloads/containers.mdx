---
title: Verwaltung und Bereitstellung von containerisierten Anwendungen
sidebar_label: Container
sidebar_position: 40
description: Verwaltung und Bereitstellung von containerisierten Anwendungen
tags:
  - Container
  - Docker
---

import PlanCompatibility from "@site/src/components/PlanCompatibility";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import TerraformExample from "@site/docs/platform/workloads/examples/_container-terraform.md";
import RegistryTerraformExample from "@site/docs/platform/workloads/examples/_containerregistry-terraform.md";
import IngressTerraformExample from "@site/docs/platform/workloads/examples/_containeringress-terraform.md";
import TerraformResourceHint from "@site/src/components/TerraformResourceHint";
import OperationLink from "@site/src/components/OperationLink";
import OperationExample from "@site/src/components/OperationExample";

<PlanCompatibility features={["container"]} />

## Starten einer containerisierten Anwendung

<Tabs groupId="access-mode">
  <TabItem value="gui" label="mStudio UI">
    Um einen Container über das mStudio zu starten, folge diesen Schritten:

    1. Navigiere zu dem Projekt, in dem du den Container erstellen möchtest.
    2. Wähle den Menüpunkt "Container" in der Seitenleiste aus.
    3. Klicke auf die Schaltfläche "Container erstellen".
    4. Wähle im Installationsassistenten das Container-Image aus, das verwendet werden soll, um deine Anwendung zu starten, und schließe den Assistenten ab, indem du die gewünschte Konfiguration bezüglich Umgebungsvariablen, Volumes und Netzwerkports angibst.

    Der interne DNS-Name deines Containers wird aus dem Namen des Containers abgeleitet. Wenn du beispielsweise einen Container mit dem Namen "Mein Container" erstellst, ist der daraus abgeleitete interne DNS-Name `mein-container`. Du kannst den internen DNS-Namen in der UI einsehen, nachdem der Container erstellt wurde.

  </TabItem>
  <TabItem value="cli" label="CLI">
    Um einen Container über die CLI zu starten, kannst du den Befehl `mw container run` verwenden:

    ```shellsession
    $ mw container run \
      --name my-container \
      --env FOO=BAR \
      -p 8000:8000/tcp \
      my-registry/my-container:latest
    ```

    Weitere Informationen findest du in der Dokumentation zum [`mw container run` Befehl](/docs/v2/cli/reference/container#mw-container-run---token-value--q--p-value--e-value---env-file-value---description-value---entrypoint-value---name-value--p-value--p--v-value-image-command-args).

    Wenn du eine Docker Compose-kompatible Datei hast, kannst du auch den Befehl `mw stack deploy` verwenden, um die gesamte `docker-compose.yml` Datei zu deployen:

    ```shellsession
    $ mw stack deploy
    ```

    Weitere Informationen findest du in der Dokumentation zum [`mw stack deploy` Befehl](/docs/v2/cli/reference/stack#mw-stack-deploy).

  </TabItem>
  <TabItem value="terraform" label="Terraform">
    Um einen Container mit Terraform bereitzustellen, kannst du das folgende Beispiel verwenden:

    <TerraformExample />
    <TerraformResourceHint resource="container_stack" />

  </TabItem>
  <TabItem value="api" label="API">
    Um zu erfahren, wie man einen Container über die API bereitstellt, lies den Artikel ["Einen Container starten"](../../../api/howtos/create-container).
  </TabItem>
</Tabs>

## Container mit Ressourcenlimits starten {#resource-limits}

Du kannst Container mit CPU- und Arbeitsspeicher-Limits starten, um die Ressourcen zu kontrollieren, die deine containerisierte Anwendung verbrauchen kann. Dies ist nützlich, um sicherzustellen, dass deine Container nicht mehr Ressourcen verbrauchen als erwartet, und um die Ressourcenzuweisung über mehrere Container hinweg zu optimieren.

<Tabs groupId="access-mode">
  <TabItem value="cli" label="CLI">
    Um einen Container mit Ressourcenlimits über die CLI zu starten, kannst du die Flags `--cpus` und `--memory` mit dem Befehl `mw container run` verwenden:

    ```shellsession
    $ mw container run \
      --name my-container \
      --cpus 0.5 \
      --memory 512m \
      --env FOO=BAR \
      -p 8000:8000/tcp \
      my-registry/my-container:latest
    ```

    Das `--cpus`-Flag gibt die maximale Anzahl an CPUs an, die der Container verwenden kann (z. B. `0.5` für eine halbe CPU, `2` für zwei CPUs). Das `--memory`-Flag gibt die maximale Menge an Arbeitsspeicher an, die der Container verwenden kann (z. B. `512m` für 512 Megabyte, `1g` für 1 Gigabyte).

    Wenn du eine Docker Compose-kompatible Datei hast, kannst du Ressourcenlimits auch mit der standardmäßigen Docker Compose-Syntax angeben:

    ```yaml
    services:
      mycontainer:
        image: my-registry/my-container:latest
        ports:
          - "8000:8000/tcp"
        environment:
          FOO: BAR
        deploy:
          resources:
            limits:
              cpus: '0.5'
              memory: 512m
    ```

    Dann deploye den Stack mit dem Befehl `mw stack deploy`:

    ```shellsession
    $ mw stack deploy
    ```

    Weitere Informationen findest du in der Dokumentation zum [`mw container run` Befehl](/docs/v2/cli/reference/container#mw-container-run---token-value--q--p-value--e-value---env-file-value---description-value---entrypoint-value---name-value--p-value--p--v-value-image-command-args).

  </TabItem>
  <TabItem value="api" label="API">
    Um einen Container mit Ressourcenlimits über die API zu starten, verwende die <OperationLink operation="container-declare-stack" apiVersion="v2" />-Operation mit dem Feld `deploy.resources.limits` in der Service-Definition:

    <OperationExample
      operation="container-declare-stack"
      example={{
        services: {
          mycontainer: {
            image: "my-registry/my-container:latest",
            ports: ["8000:8000/tcp"],
            environment: {
              FOO: "BAR",
            },
            deploy: {
              resources: {
                limits: {
                  cpus: "0.5",
                  memory: "512m",
                },
              },
            },
          },
        },
      }}
    />

    Das Feld `cpus` gibt die maximale Anzahl an CPUs an, die der Container verwenden kann (als String, z. B. `"0.5"` für eine halbe CPU). Das Feld `memory` gibt die maximale Menge an Arbeitsspeicher an, die der Container verwenden kann (z. B. `"512m"` für 512 Megabyte, `"1g"` für 1 Gigabyte).

  </TabItem>
</Tabs>

## Verwendung privater Registries {#private-registries}

Wenn dein Container-Image aus einer privaten Registry geladen werden soll, musst du diese Registry zuerst für das jeweilige Projekt definieren. Du kannst eine Registry wie folgt erstellen:

<Tabs groupId="access-mode">
  <TabItem value="gui" label="mStudio UI">
    Um eine neue Container-Registry über das mStudio zu erstellen, folge diesen Schritten:

    1. Navigiere zu dem Projekt, in dem du den Container erstellen möchtest.
    2. Wähle den Menüpunkt "Container" in der Seitenleiste aus.
    3. Wechsle zum Tab "Registries".
    4. Klicke auf die Schaltfläche "Registry hinzufügen".
    5. Konfiguriere die Registry-URL und die Anmeldeinformationen für die Registry.

  </TabItem>
  <TabItem value="cli" label="CLI">
    Um eine neue Container-Registry über die CLI zu erstellen, verwende den Befehl `mw registry create`:

    ```shellsession
    $ mw registry create \
      --description "Meine Registry"
      --uri registry.my-company.example
      --username my-user
    ```

    Wenn du einen `--username`-Parameter für eine private Registry angibst, fragt der Befehl interaktiv nach dem Passwort. Du kannst auch den `--password`-Parameter verwenden; beachte aber, dass das Passwort in diesem Fall in deiner Shell-History erscheinen könnte.

    Weitere Informationen findest du in der Dokumentation zum [`mw registry create` Befehl](/docs/v2/cli/reference/registry#mw-registry-create).

  </TabItem>
  <TabItem value="terraform" label="Terraform">
    Um eine Container-Registry mit Terraform zu definieren, kannst du das folgende Beispiel verwenden:

    <RegistryTerraformExample />
    <TerraformResourceHint resource="container_registry" />

    Beim Anwenden deiner Konfiguration kannst du entweder die Registry-Anmeldeinformationen in einer `.tfvars`-Datei definieren oder das `-var`-Flag verwenden, um sie zu übergeben. Das Passwort ist ein schreibgeschütztes Attribut, das nicht in der State-Datei gespeichert wird. Du musst `password_wo_version` erhöhen, wann immer sich das Passwort ändert.

    ```shellsession
    $ terraform apply -var registry_credentials='{"username": "username", "password": "password", "password_version": 1}'
    ```

  </TabItem>
  <TabItem value="api" label="API">
    Um zu erfahren, wie man eine Container-Registry über die API erstellt oder ändert, lies den Artikel ["Einen Container starten"](../../../api/howtos/create-container).
  </TabItem>
</Tabs>

:::note
Verwechsle nicht "private" Registry mit selbst-gehostet, was im nächsten Kapitel erklärt wird.
:::

## Eigene, selbst-gehostete Docker-Image-Registry {#self-hosted-registries}

Wenn keine private Registry existiert oder aus irgendeinem Grund nicht verfügbar ist, kannst du deine eigene Docker-Image-Registry im mittwald Container-Hosting hosten.

:::note
Um dieser Anleitung zu folgen, müssen wir Dateien über den Befehl `mw container cp` übertragen.
Stelle sicher, dass du den SSH-Zugriff auf deine Umgebung vorbereitet hast, siehe [diese Anleitung](../../../cli/usage/intro).
:::

Weitere detaillierte Anweisungen und Konfigurationsoptionen findest du in [dieser Anleitung](https://distribution.github.io/distribution/about/deploying/).

<Tabs groupId="access-mode">
  <TabItem value="gui" label="mStudio UI">
    Um eine neue Container-Registry über das mStudio zu erstellen, folge diesen Schritten:

    1. Navigiere zu dem Projekt, in dem du den Container erstellen möchtest.
    2. Wähle den Menüpunkt "Container" in der Seitenleiste aus.
    3. Klicke im geöffneten "Container"-Tab auf die Schaltfläche "Erstellen".
    4. Konfiguriere den Container nach Bedarf und verwende das Image `library/registry:3`.
    5. Richte Umgebungsvariablen nach deinen Wünschen ein, siehe die obige Anleitung für Details.

  </TabItem>
  <TabItem value="cli" label="CLI">
    Um eine neue Container-Registry über die CLI zu erstellen, verwende den Befehl `mw container run`:

    ```shellsession
    user@local $ mw container run \
      --name example-registry \
      --volume registry-data:/var/lib/registry \
      --publish 5000:5000/tcp \
      --create-volumes \
      library/registry:3
    ```

    Umgebungsvariablen für die Konfiguration können über die Option `--env` hinzugefügt werden, siehe die obige Anleitung für Konfigurationsoptionen.
    Weitere Informationen findest du in der Dokumentation zum [`mw container run` Befehl](/docs/v2/cli/reference/container/#mw-container-run).

  </TabItem>
  <TabItem value="api" label="API">
    Um zu erfahren, wie man eine Container-Registry über die API erstellt oder ändert, lies den Artikel ["Einen Container starten"](../../../api/howtos/create-container).
  </TabItem>
</Tabs>

Die in diesem Kapitel eingerichtete Registry kann als private Registry verwendet werden. Stelle daher sicher, dass die Registry erreichbar ist, z.B. indem du eine Subdomain in deinem Projekt erstellst, die auf die eigene Registry verweist.

Eine eigene Registry könnte beispielsweise eine Domain wie `docker.p-XXXXXX.project.space` haben, die als Registry für zukünftige Container-Deployments konfiguriert werden kann.

:::warning
Ohne zusätzliche Konfiguration ist diese Registry öffentlich und ohne Authentifizierung verfügbar.
Wenn eine Anmeldung über Zugangsdaten gewünscht ist, folge den nächsten Schritten, um eine Basis-Authentifizierung einzurichten.
:::

### Basis-Authentifizierung für selbst-gehostete Docker-Registry {#docker-registry-basic-auth}

Um eine Basis-Authentifizierung zu unserer Registry hinzuzufügen, müssen wir Zugangsdaten vorbereiten, die wir dann in unsere Registry deployen.

Der erste Schritt besteht darin, die Anmeldedatei **lokal** zu erstellen:

```shellsession
user@local $ mkdir -p auth
user@local $ docker run \
  --entrypoint htpasswd \
  httpd:2 -Bbn exampleuser examplepassword > auth/htpasswd
```

Dies erstellt die `htpasswd`-Anmeldedatei, die wir jetzt übertragen müssen.

:::warning
Denke daran, `exampleuser` und `examplepassword` durch geeignete Zugangsdaten zu ersetzen.
:::

:::note
Diese Anleitung zeigt die Einrichtungsschritte getrennt, obwohl im `CLI`-Modus vieles mit einem Befehl erledigt werden kann.
Wenn du bereits mit der `CLI` vertraut bist und nur die richtigen Befehle benötigst, springe gerne ans Ende der Anleitung, die die vollständigen Befehle ohne Zwischenschritte zur Erklärung bereitstellt.
:::

Um die Anmeldedatei persistent zu speichern, beginnen wir mit der Erstellung eines neuen Volumes für unseren Registry-Container:

<Tabs groupId="access-mode">
  <TabItem value="gui" label="mStudio UI">
    Um ein neues Container-Volume über das mStudio zu erstellen, folge diesen Schritten:

    1. Navigiere zu dem Projekt, in dem du die Registry erstellt hast.
    2. Wähle den Menüpunkt "Container" in der Seitenleiste aus und wähle dann den Registry-Container aus.
    3. Navigiere im geöffneten "Container"-Tab zum Tab "Volumes".
    4. Klicke im Tab "Volumes" auf "Erstellen".
    5. Konfiguriere den neuen Volume-Einhängepunkt auf `/auth` und klicke auf "Speichern".

  </TabItem>
  <TabItem value="cli" label="CLI">
    Um ein neues Volume über die CLI zu erstellen, verwende den Befehl `mw volume create`:

    ```shellsession
    user@local $ mw volume create registry-auth
    ```

    Nach der Volume-Erstellung können wir es über `mw container update` an unseren Container anhängen:

    ```shellsession
    user@local $ mw container update \
      c-XXXXXX \
      -v registry-auth:/auth \
      -v registry-data:/var/lib/registry
    ```

    :::note
    Der obige Befehl enthält noch nicht die für die Basis-Authentifizierung benötigten Umgebungsvariablen. Diese folgen im nächsten Schritt.
    Du kannst diesen Schritt überspringen und stattdessen einen vollständigen Update-Befehl im nächsten Abschnitt verwenden.
    :::

  </TabItem>
  <TabItem value="api" label="API">
    Um zu erfahren, wie man eine Container-Registry über die API erstellt oder ändert, lies den Artikel ["Einen Container starten"](../../../api/howtos/create-container).
  </TabItem>
</Tabs>

Danach konfigurieren wir unsere Registry neu, um die neuen Basis-Authentifizierungs-Zugangsdaten zu verwenden.

<Tabs groupId="access-mode">
  <TabItem value="gui" label="mStudio UI">
    Um die Konfiguration des selbst-gehosteten Registry-Containers abzuschließen, folge diesen Schritten:

    1. Navigiere zu dem Projekt, in dem du die Registry erstellt hast.
    2. Wähle den Menüpunkt "Container" in der Seitenleiste aus und wähle dann den Registry-Container aus.
    3. Navigiere im geöffneten "Container"-Tab zum Tab "Umgebungsvariablen".
    4. Verwende die Schaltfläche "Hinzufügen", um Umgebungsvariablen wie folgt zu erstellen:

    ```env
    REGISTRY_AUTH=htpasswd
    REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm
    REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd
    ```

  </TabItem>
  <TabItem value="cli" label="CLI">
    Um Umgebungsvariablen über die CLI hinzuzufügen oder zu aktualisieren, verwende den Befehl `mw container update`:

    ```shellsession
    user@local $ mw container update \
      c-XXXXXX \
      -v registry-auth:/auth \
      -v registry-data:/var/lib/registry \
      -e "REGISTRY_AUTH=htpasswd" \
      -e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm" \
      -e "REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd"
    ```

    Hier ist ein vollständiger `container run`-Befehl, wenn du von Grund auf neu beginnst oder vorgesprungen bist:

    ```shellsession
    user@local $ mw container run \
      --name example-registry \
      --volume registry-data:/var/lib/registry \
      --volume registry-auth:/auth \
      --publish 5000:5000/tcp \
      --create-volumes \
      -e "REGISTRY_AUTH=htpasswd" \
      -e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm" \
      -e "REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd" \
      library/registry:3
    ```

  </TabItem>
  <TabItem value="api" label="API">
    Um zu erfahren, wie man eine Container-Registry über die API erstellt oder ändert, lies den Artikel ["Einen Container starten"](../../../api/howtos/create-container).
  </TabItem>
</Tabs>

Erstelle den Container mit den festgelegten Volumes und Umgebungsvariablen.
Dann übertragen wir unsere Anmeldedatei und überschreiben die Standard-Benutzerzugangsdaten (die bei Bedarf in den Logs zu finden sind).

```shellsession
user@local $ mw container cp -r auth/ example-registry:/
```

Als letzten Schritt erstelle eine Subdomain in deinem Projekt und verweise sie auf den Registry-Container.

<Tabs groupId="access-mode">
  <TabItem value="gui" label="mStudio UI">
    Um eine Subdomain in deinem Projekt hinzuzufügen und zu verlinken, folge diesen Schritten:

    1. Navigiere zu dem Projekt, in dem du die Registry erstellt hast.
    2. Wähle den Menüpunkt "Domains" in der Seitenleiste aus und klicke dann auf "Hinzufügen" -> "Subdomain".
    3. Verwende als Subdomain zum Beispiel `docker.p-XXXXXX.project.space`.
    4. Wähle den Registry-Container als Ziel aus und klicke auf "Erstellen".

  </TabItem>
  <TabItem value="cli" label="CLI">

    ```shellsession
    user@local $ mw domain virtualhost create \
      --hostname docker.p-XXXXXX.project.space \
      --path-to-container /:<Container-UUID>:5000/tcp
    ```

  </TabItem>
  <TabItem value="api" label="API">
    Um zu erfahren, wie man eine Container-Registry über die API erstellt oder ändert, lies den Artikel ["Einen Container starten"](../../../api/howtos/create-container).
  </TabItem>
</Tabs>

Nachdem die Domain eingerichtet wurde, können wir mit dem Testen beginnen. Da wir die Basis-Authentifizierung konfiguriert haben, sollten wir überprüfen, ob unsere Registry diese tatsächlich verwendet. Erstelle und tagge ein beliebiges Docker-Image und pushe es dann zur neuen Registry:

```shellsession
user@local $ cd path/to/your/project
user@local $ docker build -t <Your Image> .
user@local $ docker tag <Your Image>:latest docker.p-XXXXXX.project.space/<Your Image>
user@local $ docker push docker.p-XXXXXX.project.space/<Your Image>:latest
```

Dein Push **muss** aufgrund fehlender Basis-Authentifizierungs-Zugangsdaten abgelehnt werden:

```shellsession
user@local $ docker push docker.p-XXXXXX.project.space/<Your Image>:latest
...
push access denied, repository does not exist or may require authorization: authorization failed: no basic auth credentials
```

Wenn es ohne Fehler funktioniert hat, ist deine Einrichtung unvollständig und keine Authentifizierung ist aktiv!
Melde dich jetzt an:

```shellsession
user@local $ docker login docker.p-XXXXXX.project.space
```

:::note
Denke beim Testen daran, dich speziell von deiner Registry über `docker logout docker.p-XXXXXX.project.space` abzumelden.
:::

Wiederhole `docker push`, was jetzt nach erfolgreicher Anmeldung funktioniert!
Herzlichen Glückwunsch, du hast erfolgreich deine eigene private, selbst-gehostete Docker-Registry erstellt.
Abhängig von deiner Projektstruktur und deinem Anwendungsfall kann eine generische Docker-Registry in einem separaten Projekt **oder** eine Registry pro Projekt erstellt und verwendet werden.

## Deployment-Strategien {#deployment-strategies}

Wenn du deine Anwendung mithilfe von Containern deployst, wirst du typischerweise neue Versionen deiner Anwendung bereitstellen, indem du ein neues Container-Image erstellst und es im selben Container-Stack bereitstellst. Dies ist eine gängige Praxis in containerisierten Umgebungen, da sie eine einfache Versionierung und Rückgängigmachung ermöglicht.

Es gibt zwei Varianten dieses Ansatzes:

1. **Immutable Deployment**: Jede neue Version der Anwendung wird in einem neuen Container-Image bereitgestellt, und das alte Image wird für Rollback-Zwecke aufbewahrt. Dies ist der häufigste Ansatz in containerisierten Umgebungen.
2. **Mutable Deployment**: Dasselbe Container-Image (im einfachsten Fall das `latest`-Tag) wird für alle Versionen der Anwendung verwendet, und jede neue Version ersetzt die alte.

Beide Strategien können mit mStudio-Containern implementiert werden. Die folgenden Abschnitte beschreiben, wie man sie umsetzt.

### Ein neues Tag für jedes Release pushen

Mit dieser Strategie erstellst du ein neues Container-Image für jedes Release deiner Anwendung. Mit `docker`-Befehlen könnte das so aussehen (das `v1.0.1`-Tag ist nur ein Beispiel für ein Tag, das mit jedem Release erhöht werden könnte):

```bash
docker build -t my-registry/my-container:v1.0.1 .
docker push my-registry/my-container:v1.0.1
```

:::note

Dieser Artikel ist nicht als Tutorial zum Erstellen von Docker-Images gedacht. Sieh dir den Abschnitt [Best Practices für das Erstellen](https://docs.docker.com/build/building/best-practices/) aus der Docker-Dokumentation an, um mehr darüber zu erfahren, wie man Docker-Images erstellt.

:::

Nachdem das Image erstellt wurde, kannst du es in deinem Container-Stack bereitstellen.

<Tabs groupId="access-mode">
  <TabItem value="cli" label="CLI">
    Um das Container-Image eines bestehenden Containers zu aktualisieren, verwende den Befehl `mw container update`:

    ```shellsession
    $ mw container update \
      --image my-registry/my-container:v1.0.1 \
      my-container
    ```

  </TabItem>
  <TabItem value="terraform" label="Terraform">
    Wenn du Terraform verwendest, um deine containerisierte Anwendung zu deployen, kannst du eine Terraform-Variable verwenden, um das Image-Tag festzulegen. Dies ermöglicht es dir, das Image-Tag für jedes Release einfach zu ändern:

```hcl
variable "image_tag" {
  type = string
}

resource "mittwald_container_stack" "my_application" {
  project_id    = mittwald_project.example.id
  default_stack = true

  containers = {
    mycontainer = {
      image = "my-registry/my-container:${var.image_tag}"
      // ...
    }
  }
}
```

    Wenn du `terraform apply` ausführst, kannst du die Variable `image_tag` auf die gewünschte Version setzen:

```bash
terraform apply -var="image_tag=v1.0.1"
```

  </TabItem>
  <TabItem value="api" label="API">
    Mit der API kannst du die <OperationLink operation="container-update-stack" apiVersion="v2" />-Operation verwenden, um das Image des Container-Stacks mit dem neuen Image zu ersetzen.

    <OperationExample operation="container-update-stack" example={{
      "services": {
        "mycontainer": {
          "image": "my-registry/my-container:v1.0.1"
        }
      }
    }} />

    Nach dem Aktualisieren des Images muss der Container explizit neu erstellt werden, um die Änderungen anzuwenden. Dies kann mit der <OperationLink operation="container-recreate-service" apiVersion="v2" />-Operation erfolgen.

  </TabItem>
</Tabs>

### Aktualisieren eines veränderlichen Tags

Mit dieser Strategie wirst du typischerweise immer wieder dasselbe Container-Image-Tag aktualisieren. Mit `docker`-Befehlen könnte das so aussehen:

```bash
docker build -t my-registry/my-container:latest .
docker push my-registry/my-container:latest
```

Standardmäßig werden Container-Images nicht automatisch aktualisiert, wenn das Image-Tag nicht geändert wird. Du kannst die <OperationLink operation="container-pull-image-for-service" apiVersion="v2" />-Operation oder den CLI-Befehl `mw container recreate --pull` verwenden, um das neueste Image für den Container-Stack zu ziehen. Dies wird das Image-Tag auf die neueste Version aktualisieren.

## Verwendung von Volumes

Um persistente Daten in deiner containerisierten Anwendung zu verwalten, kannst du Volumes verwenden. Volumes sind eine Möglichkeit, Daten außerhalb des Containers zu speichern, sodass sie nicht verloren gehen, wenn der Container gestoppt oder entfernt wird.

Du kannst zwei verschiedene Arten von Volumes verwenden:

1. Das **Projekt-Volume** ist ein Volume, das für jedes Projekt erstellt wird und von allen Containern und allen Managed Apps in diesem Projekt zugänglich ist. Dies ist nützlich, um Daten zwischen Containern und Apps zu teilen.
2. Du kannst auch **Volumes als Teil eines Stacks deklarieren**. Diese sind an den Container-Stack gebunden und von anderen Stacks nicht zugänglich. Dies ist nützlich, um Daten zu speichern, die nur von einem bestimmten Container-Stack benötigt werden.

### Verwendung des Projekt-Volumes

Um das Projekt-Volume zu verwenden, verwende eine Volume-Deklaration wie diese:

<OperationExample
  operation="container-declare-stack"
  example={{
    services: {
      mycontainer: {
        image: "my-registry/my-container:v1.0.1",
        volumes: ["/home/p-XXXXX/html:/var/www"],
      },
    },
  }}
/>

### Deklarieren von Volumes in Stacks

Um ein Volume innerhalb des Stacks zu deklarieren, definiere deinen Container wie folgt:

<OperationExample
  operation="container-declare-stack"
  example={{
    services: {
      mycontainer: {
        image: "my-registry/my-container:v1.0.1",
        volumes: ["myvolume:/var/www"],
      },
    },
    volumes: {
      myvolume: {},
    },
  }}
/>

### Backup & Wiederherstellung {#backup}

Alle Volumes (sowohl Projekt-Volumes als auch Stack-Volumes) werden automatisch als Teil des Projekt-Backups gesichert. Das bedeutet, dass du deine Daten im Falle eines Ausfalls oder Datenverlusts wiederherstellen kannst.

_Aber_, ein einfaches Dateisystem-Backup ist möglicherweise nicht für alle Anwendungs-Workloads ausreichend. Wenn deine Anwendung beispielsweise eine Datenbank verwendet, solltest du sicherstellen, dass die Datenbank sich in einem konsistenten Zustand befindet, bevor du ein Backup machst. Dies kann durch die Verwendung der integrierten Backup-Funktionalität der Datenbank oder durch die Verwendung einer Drittanbieter-Backup-Lösung erfolgen.

## Netzwerkverbindung zwischen Containern und Apps {#stack-network-connectivity}

Managed Apps und Container sind mit demselben Netzwerk verbunden. Das bedeutet, dass du auf Apps von deinen Containern und umgekehrt zugreifen kannst. Der Hostname des Containers ist der Schlüssel des Containers in der Stack-Definition; wenn du den Container über die UI erstellt hast, wird der Hostname aus dem Namen des Containers abgeleitet. Wenn du beispielsweise einen Container mit dem Namen `Mein Container` erstellst, wird der interne DNS-Name `mein-container` sein. Du kannst den internen DNS-Namen in der UI einsehen, nachdem der Container erstellt wurde.

Um einen Containerport von innerhalb deines Projekts zugänglich zu machen, kannst du die `ports`-Eigenschaft in der Container-Deklaration verwenden. Das erstellt eine Portzuordnung zwischen dem Containerport und dem per DNS ansprechbaren Service, auf den du aus dem Rest deiner Hosting-Umgebung zugreifen kannst. Um beispielsweise den Port 80 des Containers für andere Workloads, die im selben Projekt laufen (sei es andere Container oder verwaltete Apps), zugänglich zu machen, kannst du die folgende Deklaration verwenden:

<OperationExample
  operation="container-declare-stack"
  example={{
    services: {
      mycontainer: {
        image: "my-registry/my-container:latest",
        ports: ["80:80/tcp"],
      },
    },
  }}
/>

## Container über HTTP aus dem Internet zugänglich machen {#ingress-http}

Um einen Container-HTTP-Port aus dem Internet zugänglich zu machen, musst du eine Ingress-Ressource definieren, die auf den gegebenen Container verweist.

:::important Wichtig: Nur HTTP

Dieser Abschnitt gilt nur für HTTP(S)-Traffic. Dabei ist es nicht wichtig, auf welchem Port der Container lauscht (solange er in der jeweiligen Container-Konfiguration als `port` definiert ist).

Externer Zugriff für andere Anwendungsprotokolle als HTTP(S) wird derzeit nicht unterstützt. Bitte stimme für die entsprechende [Feature-Anfrage](https://github.com/mittwald/feature-requests/issues/246) ab.

:::

<Tabs groupId="access-mode">
  <TabItem value="cli" label="CLI">

    Um eine Ingress-Ressource mit einem Container zu verknüpfen, benutze den `mw domain virtualhost create`-Befehl mit dem `--path-to-container`-Flag:

    ```shellsession
    mw domain virtualhost create --hostname domain.example --path-to-container /:[container-uid]:80/tcp
    ```

    Das `--path-to-container`-Flag sollte drei Werte enthalten, getrennt durch Doppelpunkte:

    1. Der URL-Pfad, der auf den Container verweist.
    2. Die Container-ID.
    3. Der Port (im Format `portnummer/protokoll`, also beispielsweise `80/tcp`), auf dem der Container lauscht.

  </TabItem>
  <TabItem value="terraform" label="Terraform">

    Verwende eine `mittwald_virtualhost`-Ressource, um eine Ingress-Ressource für deinen Container zu erstellen. Das folgende Beispiel zeigt, wie man eine Ingress-Ressource für einen Container erstellt:

    <IngressTerraformExample />
    <TerraformResourceHint resource="virtualhost" />

  </TabItem>
  <TabItem value="api" label="API">

    <OperationExample
      operation="ingress-create-ingress"
      example={{
        hostname: "some-hostname.example",
        projectId: "<project-id>",
        paths: [
          {
            path: "/",
            target: {
              container: {
                id: "<container-id>",
                portProtocol: "80/tcp",
              },
            },
          },
        ],
      }}
    />

  </TabItem>
</Tabs>
